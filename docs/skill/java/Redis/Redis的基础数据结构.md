> `Reids` 所有的数据结构都以唯一的 `key` 字符串作为名称，然后通过这个唯一的 `key` 值来获取相应的 `value` 数据。不同的数据结构差异就在于 `value` 的结构不一样。

## [#](#一、redis-五大数据类型) 一、`Redis` 五大数据类型

【1】**`String`**（字符串）**：**`String` 是`Redis` 最基本的类型，一个 `key` 对应一个`value`。`String` 类型是二进制安全的。意思是 `Redis` 的 `String` 可以包含任何数据。**一个键最大能存储 512MB**。  
【2】**`Hash`**（哈希）**：**`Hash` 是一个键值对集合，类似 `Java` 里的 `Map`。`Redis` 的 `Hash` 是 一个 `String` 类型的 `filed` 和 `value` 的映射表，`hash` 特别适合存储对象。  
【3】**`List`**（列表）**：**`Redis` 列表是简单的字符串列表，按照插入顺序排序，可以在列表的头部或者尾部插入新的节点。  
【4】**`Set`**（集合）**：**`Redis` 的 `Set` 是 `String` 类型的**无序集合**。集合是通过哈希表（散列表）实现的，所有添加、删除、查找的效率都是一样的。一个集合最多可以包含2^32-1个元素。  
【5】**`Zset`**（`sorted` `set`：**有序集合**）**：** `Reids` `Zset` 和 `Set` 一样也是 `String` 类型元素的结合，且不允许重复的成员。不同的是每个元素都会关联一个 **`double` 类型的分数 `score`**。`Redis` 正是通过分数来为集合中的成员进行从小到大的排序。`Zset` 的成员是唯一的，但是分数是可以重复的。  
【**获得 `redis`常见数据类型操作命令**】：[链接 (opens new window)](http://redisdoc.com/)

## [#](#二、redis-字符串string) 二、`Redis` 字符串`String`

> 字符串 `String` 是 `Reids` 中最简单的数据结构，如下图所示，它的内部就是一个字符数组。  
> ![String](data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAdUAAAAfCAYAAACxvVeRAAACf0lEQVR4nO2cwYrCMBRF/f9f6k/4BwruigvpoqgIcTG1phqLTJtnct+5cGGgC3MmMWcap24CIYQQQlbJ5tcDIIQQQlSCVAkhhJCVMpFqsz/IF06twqlVOLXqiROpihdOrcKpVTi1ilQLGAeccMIJp3o9cSJV8cKpVTi1CqdWkWoB44ATTjjhVK8nTqQqXji1CqdW4dTqT6S6uwwvcuvD9vV624fz38XQtvVP8sj6KZfOZJLhXN5tfxtgrmH3dr0L3XC1O9XNOWWdS973aF7OY2hHxPn5TO5T1XBGc5nkeHKe+2PWcRSxbjPP5YPzEaSak/VTBGTjhROpvqZmqR6iveZdKM/1XP8+hFTjJYtUq5/kWVajwrlOPUl12uddXe6N15ozKc8Z2dbI6VOqqfeoTZFq5l+wB9l44USqelKdHPMOpynWaxmpZmBFqlGRKpyFciJVRakeQnO6jvted3n8nH//seJEqrb9rVRnIybVZGwmHs51+t3njEi1Rs639WvwPwBWnD6lmorNH0pxkKo5q4ZsvHAiVV2pTo6Bje9yzNYtUnUgVY5/TQrnOuX4V1mq0Ro2vEu14PxWqgrrluNfpGo2yXAuL1JFqlVyjp8Z669bpIpUzSYZzuVFqki1Ss7oEaFXNqXncZs9UkWqhpMM5/IiVaRaK6eHL2dp9kgVqRpOMpzLi1SRatWc0aNDcXKvV0tOt1ItpXBqFU6twqlVT5xIVbxwahVOrcKpVaRawDjghBNOONXriROpihdOrcKpVTi1ilQLGAeccMIJp3o9cSJV8cKpVTi1CqdWkWoB44ATTjjhVK8nzqRUCSGEEPL/IFVCCCFkpSBVQgghZKXcAb4EKlkqFLjbAAAAAElFTkSuQmCC)  
> `Reids` 的字符串是动态字符串，是可以修改的字符串，内部结构的实现类似于 `Java` 的 **`ArrayList`**，**采用预分配冗余空间的方式来减少内存的频繁分配**，如下图所示：内部为当前字符串分配的实际空间 `capacity` 一般要高于实际字符串长度 `len`。需要注意的是字符串最大长度为 512MB。  
> ![String](data:image/png;base64,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)  
> **`String` 常用命令：** 支持简单的增删改查操作；  
>  ● `SET`：将字符串值 value 关联到 key。如果 key 已经持有其它值， `SET` 就覆盖旧值【`SET key value`】；  
>  ● `GET`：获取某个 `key` 的 `value` 值【`GET key`】；  
>  ● `MGET`：一次获得多个 `key` 的数据【`MGET key1 key2 ...`】，节省网络耗时开销；  
>  ● `MSET`：一次设置多个 `key` 的数据【`MSET key1 value1 key2 value2 ..`.】，节省网络耗时开销；  
>  ● `EXISTS`：判断一个键是否存在，存在返回 1；否则返回 0【`EXISTS key`】；  
>  ● `DEL`：删除某个 key 或者一些列 `key`【`DEL key1 key2 ...`】；  
>  ● `KEYS`：返回匹配的 `key` 列表（`KEYS foo*` 指查找 `foo` 开头的 `keys`）【`KEYS *`】；  
>  ● `RENAME`：更改 `key` 的名字，如果新名字已存在则更改失败【`REMANE key1 key2`】；  
>  ● `DBSIZE`：返回当前 `key` 的总数【`DBSIZE`】；  
>  ● `EXPIRE`：设置某个 `key` 的过期时间（单位：秒）【`EXPIRE key` 秒数】；  
>  ● `TTL`：查找某个 `key` 的过期时间【`TTL key`】；  
>  ● `SETEX`：设置过期时间，等价于 `set+expire` 【`SETEX key time value`】；  
>  ● `SETNX`：如果 `key` 不存在则执行 `set` 创建，返回 1。否则不创建返回 0【`SETNX key value`】；  
>  ● `INCR/DECR/INCRBY/DECRBY`：前两个是递增 1 和递减 1 【`INCR key`】，后两个是指定递增和递减的数字【`INCRBY KEY` 倍数】。前提是一定要是数字才能进行加减；

## [#](#三、redis列表list) 三、`Redis`列表`List`

> Redis 的**列表**相当于 `Java` 语言里面的 **`LinkedList`**，注意它是**链表**而不是数组。这就意味着 **`list` 的插入和删除操作非常快，时间复杂度为 ![O(1)](https://img.fuwenhao.club/blog/gif.gif)** ，但是索引定位很慢，时间复杂度为 ![O(n)](https://img.fuwenhao.club/blog/gif-20230530163516118.gif)，这点让人非常意外，如下图所示，列表中的每个元素都使用双向指针顺序，串起来可以同时支持向前向后遍历。当列表弹出最后一个元素之后，该数据结构被自动删除，内存被回收。`Redis` 的列表结构常用来做异步队列使用。将需要延后处理的任务结构体序列化成字符串，塞进 `Redis` 列表，另一个线程从这个列表中轮询数据进行处理。  
> ![List](data:image/png;base64,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)

**`List` 常用命令：** 可以通过 `push`，`pop` 操作从链表的头部或者尾部添加删除元素。`list` 既可以用作栈，也可以用作队列。  
 1）、`LPUSH`：将一个或多个值插入到列表头部【`lpush key value1 [value2 ...]`】  
 2）、`RPUSH`：从尾部加入元素（队列）先进先出【`rpush key value1 [value2 ...]`】  
 3）、`LPOP`：移除并获取列表中的第一个元素【`lpop key`】  
 4）、`RPOP`：移除并获取列表中的最后一个元素【`rpop key`】  
 5）、`LRANGE`：获取列表中指定范围内的元素【`lrange key start stop`】  
 6）、`LLEN`：获取 `List` 的长度【`llen key`】

**慢操作：`lindex`** 相对于 Java 链表的 get(int index) 方法，它需要对链表进行遍历，性能会随着参数 index 增大而变差。 `ltrim` 的两个参数 `start_index` 和 `end_index` 定义了一个区间，在这个区间内的值，**`ltrim`** 保留，区间之外的统统丢弃掉。我们可以通过 `ltrim` 实现一个定长的链表，这一点非常有用。index 可以为负数，index=-1表示倒数第一个元素，同理index=-2表示倒数第二个元素。 1）、`LINDEX KEY INDEX`：获取下标为 index 的元素（![O(n)](https://img.fuwenhao.club/blog/gif-20230530163516118.gif) 慎用）； 2）、`LRANG KEY START END`：根据下标区间获取 `value` 值； 3）、`LTRIM KEY START END`：根据下标截取 `list`，通过 `ltrim key 1 0` #表示清空这个列表，因为区间范围长度为负；

**快速列表：**如果更深入一点，会发现 `Redis` 底层存储的不是一个简单的 `LinkedList`，而是称之为 “**快速链表**”(`QuickList`)的一个结构。首先在列表元素较少的情况下，会使用**一块连续的内存存储**，这个结构是 **`ziplist`**，即**压缩列表**。它将所有的元素彼此紧挨着一起存储，分配的是一块连续的内存。当数据比较多的时候才会改成 `QuickList`。因为普通的链表需要的附加**指针空间太大**，会**浪费空间，还会增加内存的碎片化**，比如某个普通链表里面存的只是 `int` 类型的数据，结构上还需要两个额外的指针 `prev` 和 `next`。所以 `Redis` 将**链表和 `ziplist` 结合起来组成了 `quicklist`**，也就是将多个 `ziplist` 使用双向指针串起来使用。如下图所示，`quicklist` 即满足快速的插入删除特性，又不会出现太大的空间冗余。  
![ZipList](data:image/png;base64,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)

## [#](#四、redis集合set) 四、`Redis`集合`Set`

> `Redis` 的集合`Set` 相当于 `Java` 语言里面的 **`HashSet`**，它内部的键值对是无序的、唯一的。它的内部实现相当于一个特殊的`HashMap`，`HashMap` 中所有的 `value` 都是一个 `NULL` 值。当集合中最后一个元素被移除后，数据结构被自动删除，内存被回收。

**`Set` 常用命令：** `Set` 对外提供的功能与 `List` 类似是一个列表的功能，特殊之处在于 `set` 是可以**自动排重**的，并且 set 提供了判断某个成员是否在一个 `Set` 集合内的重要接口。Redis 还为集合提供了求 **交集、并集、差集** 等操作。基本命令操作如下：  
 【1】`SADD`：向集合添加一个或多个成员【`sadd key value1[value2...]`】  
 【2】`SISMEMBER`：判断集合中是否存在 `key` 的成员【`sismember key value`】  
 【3】`SMEMBERS`：返回集合中的所有成员【`smembers key`】  
 【4】`SUNION`：返回所有给定集合的**并集**【`sunion key1 [key2...]`】  
 【5】`SINTER`：返回所有给定集合的**交集**【`sinter key1 [key2...]`】  
 【6】`SDIFF`：返回所有给定集合的**差集**【`sinter key1 [key2...`\]】

## [#](#五、有序集合sorted-sets) 五、有序集合`Sorted` `sets`

> `Zset` 可能是 `Redis` 提供的最有特色的数据结构，它也是在面试中面试官最爱问的数据结构。它类似于 `Java` 的 **`SortedSet`** 和 **`HashMap`** 的结合体，一方面它是一个 `set`，保证了内部的唯一性，另一方面它可以给每个 `value` 赋予一个 `score`，代表这个 `value` 的排序权重。它的内部实现使用 “**跳跃列表**” 的数据结构；`zset` 中最后一个 `value` 被移除后，数据结构被自动删除，内存被回收；`Redis` 有序集合非常适合与那些有序无重复数据的存储，例如：游戏开发中的排行榜、登记榜、经验榜等。如果沿用传统的方式，一般是通过后端的定时任务去跑数据来完成排行榜。这种方法一方面无法满足产品对功能实时性的要求，另一方面也消耗了服务器的资源。

**`ZSet` 常用命令：** 常用命令如下：  
 1）、`ZADD`：向集合中添加一个或多个元素，或者更新已存在的元素【`zadd key score1 member1 [score2 member2]`】；  
 2）、`ZRANGE`：通过索引区间返回有序集合指定的成员【`zrange key start stop [WITHSCORES]`】；  
 3）、`ZRANK`：返回集合中指定成员的索引(下标)【`zrank key member`】；  
 4）、`ZREM`：移除有序集合中一个或多个成员【`zrem key member1 [member2 ...]`】；  
 5）、`ZREVRANGE`：逆向返回有序集中指定区间的成员，通过索引分数从高到低【`zrevrange key start stop [WITHSCORES]`】；  
 6）、`ZCARD`：相当于 `count()`【`zcard key`】；  
 7）、`ZSCORE`：获取指定 `value` 的 `score`【`zscore key value`】；  
 8）、`ZRANGBYSCORE`：根据分值区间遍历 `zset`【`zrangbyscore key start end`】；

**跳跃列表：** `zset` 内部的排序功能是通过“跳跃列表”数据结构来实现，它的结构非常特殊，也比较复杂。因为 **`zset` 要支持随机的插入和删除**，所以它不宜使用数组来表示。我们先看一个普通的链表结构：  
![zset](data:image/png;base64,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)  
此链表将按照 `score` 进行排序，当我们插入一个新元素的时候，要定位到特定的位置，才可以继续保证链表是有序的。通常我们会通过**二分查找**来找到插入点，但是二分查找的对象必须是数组，只有数组才可以支持快速位置定位，链表做不到；因此就出现了跳跃列表数据结构； 跳跃列表就类似一个 B树（层级制），最下面一层所有的元素会串起来。然后每隔几个元素挑选一个代表，再将这几个代表使用另外一个指针串起来。然后在这些代表里再调出二级代表，再串起来。最终形成一个金字塔机构。“跳跃列表”之所以“跳跃”是因为内部元素可能“身兼数职”，比如如下图所示：中间这个元素，同时处于L0、L1和L2层中，可以快速在不同层次之间进行“跳跃”。  
![score](https://img.fuwenhao.club/blog/score.071728c8.png)  
定位插入点时，现在顶层进行定位，然后下潜到下一级定位，一直下潜到最底层找到合适的位置，将新元素插进去。那么新元素如何才有机会“身兼数职”呢？跳跃列表采取一种**随机策略**决定新元素可以兼职到几层。首先位于 L0 层的概率为是 100%，而兼职L1 层的概率有 50%，到L2层的概率 25%，到L3层只有12.5%的概率，一次类推，一直随机到**最顶层L31层**。绝大多数元素都过不了几层，只有极少数元素可以深入到顶层。列表中的元素越多，够深入的层次就越深，元素能进入到顶层的可能性就会大。

## [#](#六、哈希hash) 六、哈希`Hash`

> `Redis` 的字典（`Hash`）相当于`Java` 语言里面的 **`HashMap`**，它是无序字典，内部存储了很多键值对。实现结构与 `Java` 的 `HashMap` 是一样的，都是“**数组+链表**”（`JDK1.7`）。不同的是，Redis 的字典值只能是字符串，另外他们 `rehash`（扩容后需要重新计算`hash`值，分配地址）的方式不一样，因为 `Java` 的`HashMap` 在字典很大时，`rehash` 是个耗时的操作，需要一次性全部`rehash`。`Redis` 追求性能，不能堵塞服务，所以采用了渐进式 `rehash` 策略。渐进式 `rehash` 会在 `rehash` 时保留新旧两个 `hash` 结构，查询时会同时查询两个 hash 结构，然后在后续的定时任务以及 `hash` 操作指令中，循环渐进地将旧 `hash` 的内容一点点地迁移到新的 `hash` 结构中。当迁移完成了，就会使用新的 `hash` 结构取而代之。

![HashMap](https://img.fuwenhao.club/blog/Hash.1252d067.png)

**`Hash`** **常用命令：** 当 `hash` 移除最后一个元素之后，该数据结构被自动删除，内存被回收。字典常用命令如下：  
【1】`HSET`：将哈希表 key 中的字段 `field` 的值设为 `value`【`hset key field value`】；  
【2】`HGET`：获取存储在哈希表中指定字段的值【`hget key field`】；  
【3】`HGETALL`：获取哈希表中，指定 `key` 的所有字段和值【`hgetall key`】；  
【4】`HDEL`：删除一个或多个哈希表字段【`hdel key field1 [field2...]`】；  
【5】`HMSET`：同时将多个 field-value（域-值）设置到哈希表 `key`【`hmset key field value [field1 value1 ...]`】；  
【6】`HLEN`：获取 key 中存储的元素个数【`hlen key`】；

## [#](#七、hyperloglog) 七、`Hyperloglog`

当需要做**计数统计**场景，都可以使用 **hyperloglog**，只要**允许容错**，它有 **0.81%的错误率**，如果不允许容错，就可以使用 `set`或者自己的数据类型即可。优点是**节省内存**：占用的内存是固定的,**如果要存数据，`hyperloglog`存 2^64的数据只需要占用 12kb内存。**